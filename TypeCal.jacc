//JACC Implementation of the TypeCal Grammar
%class TypeCal
%package edu.semo.jatzs.typecal
%interface TypeCalTokens
%next next()
%get lexer.getToken()
%semantic Object : lexer.getValue()
%token EQUAL ID ADD SUB MUL DIV EXP LITERAL LPAREN RPAREN SEMI
%token REAL INT END RECORD DOT

%right EQUAL
%left ADD SUB
%left MUL DIV
%right EXP

%{import edu.semo.jatzs.typecal.parsenode.*;%}

%%

calc: statements
    {
        $$ = new CalcNode((StatementListNode) $1);
    }
    ;

statement: assign
         | declaration
         | record_definition
         | expr
         ;

statements: statements SEMI statement
          {
              ((StatementListNode) $1).add(new StatementNode((ParseNode) $3));
              $$=$1;
          }
          | statement
                      {
                          $$ = new StatementListNode(new StatementNode((ParseNode) $1));
                      }
          ;

declaration: REAL ID

           { $$ = new DeclarationNode((String) $2, Type.REAL);
           System.out.println("Real Node: " + $2);}
           | INT ID
           { $$ = new DeclarationNode((String) $2, Type.INTEGER);
           System.out.println("INT Node: " + $2);}
           | ID ID
           { $$ = new RecordDeclarationNode((String)$1, (String)$2);
           System.out.println($1);
           System.out.println($2);
           }
           ;

declaration_list: declaration_list SEMI declaration
             { System.out.println($2 + " aasdgasedgads");
             System.out.println($1 + " adsfasdfasdfasdfsadfasdf");
             $$ = addDeclaration($1, $2);

             }

             | declaration
             { $$ = addDeclaration(null, $1);
             System.out.println($1);}
             ;



record_definition: RECORD ID declaration_list END
                 {
                    $$ = new RecordDefinitionNode((String) $2.toString(), (SymbolTable) $3);
                    System.out.println("Record Definition: " + $2.toString());
                 }
                 ;

assign: ref EQUAL expr
      {
          $$ = new AssignmentNode((ReferenceNode)$1, (ParseNode)$3);
      }
      ;

expr: term
    | expr ADD term
    {
        $$ = new BinaryOperationNode((ParseNode)$1, "+", (ParseNode) $3);
    }
    | expr SUB term
    {
        $$ = new BinaryOperationNode((ParseNode)$1, "-", (ParseNode) $3);
    }
    ;

term: factor
    | term MUL factor
    {
        $$ = new BinaryOperationNode((ParseNode)$1, "*", (ParseNode) $3);
    }
    | term DIV factor
    {
        $$ = new BinaryOperationNode((ParseNode)$1, "/", (ParseNode) $3);
    }
    ;
factor: exp EXP factor
      {
          $$ = new BinaryOperationNode((ParseNode)$1, "**", (ParseNode) $3);
      }
      | exp
      ;
exp: LPAREN expr RPAREN
   {
       $$ = new GroupNode((ParseNode) $2);
   }
   | ref
   | LITERAL
   {
       $$ = new LiteralNode((int) Double.parseDouble($1 + ""));
   }
   | real

   ;

ref: ID
   {
        $$ = new ReferenceNode((String) $1);
   }
   | ref DOT ID
   {
        $$ = new RecordReferenceNode((String) $1, (String) $2);
   }
   ;


real: LITERAL DOT LITERAL
{
   {
       $$ = new RealLiteralNode(Double.parseDouble($1 + "." + $2));
   }
}
;



%%
    private TypeCalLexer lexer;
    private TypeCalPT pt;
    private ParseNode calc;
    
    public TypeCal(java.io.InputStream in)
    {
        lexer = new TypeCalLexer(in);
        pt = new TypeCalPT(this);
    }


    public ParseNode getCalc()
    {
        return calc;
    }

    SymbolTable addDeclaration(Object sym, Object decl) {
        if(sym == null)
            sym = new SymbolTable();
        SymbolTable table = (SymbolTable)sym;
        table.assignValue(((DeclarationNode)decl).getName(), decl);
        return table;
    }


    public int next() {
        lexer.next();

        return lexer.getToken();
    }

    
    public void yyerror(String msg) {
           lexer.printError("ERROR: " + msg);
    }


    public static void main(String [] args) {
        try {
            TypeCal parser = new TypeCal(new java.io.FileInputStream(args[0]));
            parser.next();
            if(parser.parse()) {
                parser.getCalc().evaluate();
            }

        } catch(Exception e) {
            e.printStackTrace();
        }
    }
